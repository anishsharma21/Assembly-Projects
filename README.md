# EarlyLangs

## Introduction

Have you ever tried learning something and then realised there was a bunch of prerequisite knowledge you needed to know beforehand? I feel like this is a constant in computer science because of all the layers of abstraction that exist - the resolution seems to be that you either just deal with the discomfort of not knowing what is beneath your current layer of abstraction or you dive into the deep end and learn computer science from first principles... which is what this repo is concerned with. Specifically, it traces the chronological progression of programming over time - I believe this chronological approach is the best strategy 
for learning things deeply and an antidote to the issue of not knowing enough prerequisite knowledge - i.e. the central problem for most newbies in the CS space. This is because you are following the progression of ideas in the way they actually happened - building upon previous ideas - every new idea you learn connects directly to the ideas you just learnt, so you have all the tools and ideas you need to learn effectively - awesome.

Now, of course, assembly programming is not the lowest level of abstraction in computer science; for that, you would need to go to digital logic. I am creating this repo after covering digital logic and microarchitecture - if you truly want to learn computer science from first principles (and I encourage you to do so because it makes assembly programming and the abstractions above so much easier to understand and connect to tangible, physical ideas), then I would recommend you learn about that all that first. An absolutely amazing book for this, that takes you from lightbulbs and switches to a functioning processor, is the book, *CODE: the hidden language of computer hardware and software*, by Charles Petzold - it's easy to understand, completely beginner-friendly, beautifully written, and an absolute classic that sets a perfect foundation for your computer science journey. You can learn digital logic -> microarchitecture -> assembly all in this one book - in fact, you could even create your own breadboard computer and custom assembly language by following this book!

This repository doesn't assume any prior knowledge of digital logic and microarchitecture but that stuff provides invaluable foundation. I've covered all that already, so some technical jargon might pop up here and there in the guides I've written - speaking of which, each directory in this repo relates to a different programming language. Each of these languages has a README file that helps you get your environment set up - at least if you have a MacOS. I am running on Apple Silicon with MacOS Sonoma running - just for reference. If you're running on a different OS, the steps might be different, and honestly, when it comes to low level programming, the architecture and OS of your system does matter because compilation, assembly, and execution of programs is different for different systems - but that's expected with the work we are doing. If things don't work first time, you'll have to investigate on your own - if you find solutions/mistakes, feel free to open up an issue and I'll gladly incorporate your changes.

Anyways, with the README files, you can write and run your programs, enjoy programming at the lower levels, understand your field of choice at a deeper level, and set yourself up for future success with deep knowledge of how the field has progressed overtime, why certain decisions were made, and why that has led to your programs being written in the way they have and how to utilise both them and the layers of abstraction below most effectively - this will pay dividends for you across your career.

## Project Overview and Logs

### x86 Assembly

Initially, the project focused on x86 assembly language for the GNU/Linux environment. To facilitate development and ensure a consistent environment, the x86 assembly programs were containerised using Docker. This allowed for easy setup and execution of the programs on any machine with Docker installed... or so I thought. The reality was that unless I was using an emulator like `qemu`, I couldn't write assembly programs targetting x86 architecture (with 32 bit registers) on an ARM64 machine, or at least not as seamlessly as with ARM64 assembly.

### ARM64 Assembly

The project then transitioned to exploring ARM64 assembly language with a RISC (reduced instruction set computing) ISA. Since I am developing on a ARM64 based Mac (M3 chip), I can use the xcode tools and specifically `clang` to both assemble and link my assembly programs, making the process of writing and executing assembly programs much easier. Resources for ARM64 assembly are pretty scarce or quite terse, so its a solid challenge overall - but, I found [this really good video](https://www.youtube.com/watch?v=rg6kU42LQcY) that will get anyone with an M-chip mac up to scratch with ARM64 assembly programming on their mac's.

### MIPS Assembly

While the resources for ARM64 assembly language were better for my set up (MacOS + Apple silicon), there were still lofty barriers in the way of exploring more complex concepts like procedures, heap + stack allocation, or even writing systems software. As a result, I decided to look into MIPS - which stands for Microprocessor without Interlocked Pipeline Stages. Like ARM, its also a RISC architecture, and was made also for education purposes, so there were plenty of resources to learn from. Additionally, I was working through the book *Computer Organization and Design: The Hardware/Software Interface*, which uses MIPS as its main assembly language to illustrate concepts and programs - so being able to write MIPS on my mac made following along with this book much more effective. In particular, I was using the `SPIM` simulator/cross-assembler (which I installed using `brew install spim`) to assemble my MIPS programs and run them with a set of `spim` commands.
